"""

    作者：大发
    日期：2019/11/18
    内容：利用python进行数据分析 11.1-11.3 p303 笔记

"""

import pandas as pd
import numpy as np
from io import StringIO
from lxml import objectify
import requests
import sqlite3
import sqlalchemy as sqla
from io import StringIO
import json
from numpy import nan as NA
import re
import matplotlib.pyplot as plt
from numpy.random import randn
from datetime import datetime
from io import BytesIO
import seaborn as sns
import statsmodels.api as sm
from datetime import datetime
from datetime import timedelta
from dateutil.parser import parse
from pandas.tseries.offsets import Hour,Minute
from pandas.tseries.offsets import Day,MonthEnd


### 11.1 日期和时间数据类型及工具

# now = datetime.now()
# now
# Out[4]: datetime.datetime(2019, 11, 18, 9, 3, 21, 71754)
# now.year, now.month , now.day
# Out[5]: (2019, 11, 18)

# datetime以毫秒形式存储日期和时间。
# timedelta表示两个datetime对象之间的时间差：
# delta = datetime(2011 , 1, 7) - datetime(2008 , 6 ,24,8,15)
# delta
# Out[7]: datetime.timedelta(days=926, seconds=56700)
# delta.days
# Out[8]: 926
# delta.seconds
# Out[9]: 56700

# 给datetime对象加上（或减去）一个或多个timedelta，这样会产生一个新对象：
# start = datetime(2011,1,7)
# start+timedelta(12)
# Out[12]: datetime.datetime(2011, 1, 19, 0, 0)
# start - 2*timedelta(12)
# Out[13]: datetime.datetime(2010, 12, 14, 0, 0)


#### 11.1.1 字符串和datetime的相互转换

# datetime 的格式定义P305 电子版P346
# stamp = datetime(2011 ,1, 3)
# str(stamp)                             # str方法
# Out[15]: '2011-01-03 00:00:00'
# stamp.strftime('%Y-%m-%d')              # .strftime方法
# Out[16]: '2011-01-03'

# datetime.strptime可以用这些格式化编码将字符串转换为日期：
# datetime.strptime(value , '%Y-%m-%d')
# Out[19]: datetime.datetime(2011, 1, 3, 0, 0)
# datestrs = ['7/6/2011' , '8/6/2011']
# [datetime.strptime(x,'%m/%d/%Y')for x in datestrs]
# Out[21]: [datetime.datetime(2011, 7, 6, 0, 0), datetime.datetime(2011, 8, 6, 0, 0)]

# 用dateutil这个第三方包中的parser.parse方法
# dateutil可以解析几乎所有人类能够理解的日期表示形式：
# parse('2011-01-03')
# Out[22]: datetime.datetime(2011, 1, 3, 0, 0)
# parse('Jan 31, 1997 10:45 PM')
# Out[23]: datetime.datetime(1997, 1, 31, 22, 45)

# 在国际通用的格式中，日出现在月的前面很普遍，
# 传入dayfirst=True即可解决这个问题：
# parse('6/12/2011', dayfirst=True)
# Out[24]: datetime.datetime(2011, 12, 6, 0, 0)

# to_datetime方法可以解析多种不同的日期表示形式。
# 对标准日期格式（如ISO8601）的解析非常快：
# datestrs = ['2011-07-06 12:00:00','2011-08-06 00:00:00']
# pd.to_datetime(datestrs)
# Out[28]: DatetimeIndex(['2011-07-06 12:00:00', '2011-08-06 00:00:00'], dtype='datetime64[ns]', freq=None)

# 可以处理缺失值（None、空字符串等）：
# idx = pd.to_datetime(datestrs + [None])
# idx
# Out[30]: DatetimeIndex(['2011-07-06 12:00:00', '2011-08-06 00:00:00', 'NaT'], dtype='datetime64[ns]', freq=None)
# idx[2]
# Out[31]: NaT
# pd.isnull(idx)
# Out[32]: array([False, False,  True])
#
# NaT（Not a Time）是pandas中时间戳数据的null值。



#### 11.2 时间序列基础

# pandas最基本的时间序列类型就是以时间戳（通常以Python字符串或
# datatime对象表示）为索引的Series：

# dates = [datetime(2011, 1, 2), datetime(2011, 1, 5),
#          datetime(2011, 1, 7), datetime(2011, 1, 8),
#          datetime(2011, 1, 10), datetime(2011, 1, 12)]
# ts = pd.Series(np.random.randn(6) , index = dates)
# ts
# Out[35]:
# 2011-01-02    0.914789
# 2011-01-05    0.489796
# 2011-01-07   -0.617048
# 2011-01-08   -0.066532
# 2011-01-10    1.075925
# 2011-01-12    0.860212
# dtype: float64

# 这些datetime对象实际上是被放在一个DatetimeIndex中的：
# ts.index
# Out[36]:
# DatetimeIndex(['2011-01-02', '2011-01-05', '2011-01-07', '2011-01-08',
#                '2011-01-10', '2011-01-12'],
#               dtype='datetime64[ns]', freq=None)

# 跟其他Series一样，不同索引的时间序列之间的算术运算会自动按日期对齐：
# ts + ts[::2]           # ts[::2] 是每隔两个取一个
# Out[37]:
# 2011-01-02    1.829579
# 2011-01-05         NaN
# 2011-01-07   -1.234096
# 2011-01-08         NaN
# 2011-01-10    2.151850
# 2011-01-12         NaN
# dtype: float64

# pandas用NumPy的datetime64数据类型以纳秒形式存储时间戳：
# ts.index.dtype
# Out[38]: dtype('<M8[ns]')

# DatetimeIndex中的各个标量值是pandas的Timestamp对象：
# stamp = ts.index[0]
# stamp
# Out[40]: Timestamp('2011-01-02 00:00:00')

# 11.2.1 索引、选取、子集构造

# 根据时间序列进行索引
# stamp = ts.index[2]
# ts[stamp]
# Out[42]: -0.6170482396751186

# 传入一个可以被解释为日期的字符串：
# ts['1/10/2011']
# Out[43]: 1.075924897393425
# ts['20110110']
# Out[44]: 1.075924897393425

# 对于较长的时间序列，只需传入“年”或“年月”即可轻松选取数据的切片：
#
# longer_ts = pd.Series(np.random.randn(1000), index = pd.date_range('1/1/2000' , periods = 1000))
# longer_ts
# Out[46]:
# 2000-01-01    0.479647
# 2000-01-02    0.289630
# 2000-01-03    0.332328
# 2000-01-04    0.469234
# 2000-01-05   -0.454753
# 2000-01-06    1.327596
# 2000-01-07    0.582900
# 2000-01-08   -1.336987
# 2000-01-09    1.930167
# 2000-01-10   -0.035206
# 2000-01-11    1.151172
# 2000-01-12   -0.045058
# 2000-01-13    0.166991
# 2000-01-14   -0.169926
# 2000-01-15   -0.593541
# 2000-01-16   -0.583374
# 2000-01-17    1.183246
# 2000-01-18    0.725433
# 2000-01-19    0.751173
# 2000-01-20    0.676573
# 2000-01-21   -0.744931
# 2000-01-22    0.442559
# 2000-01-23    0.096098
# 2000-01-24   -0.891107
# 2000-01-25    0.958702
# 2000-01-26    0.538300
# 2000-01-27    0.143427
# 2000-01-28    0.412863
# 2000-01-29    0.580080
# 2000-01-30   -0.318433
#                 ...
# 2002-08-28   -0.532771
# 2002-08-29    0.181193
# 2002-08-30    0.245531
# 2002-08-31    0.499037
# 2002-09-01   -1.187730
# 2002-09-02    0.830525
# 2002-09-03    0.174313
# 2002-09-04    0.999942
# 2002-09-05    0.513370
# 2002-09-06   -1.229480
# 2002-09-07   -0.430835
# 2002-09-08    0.613965
# 2002-09-09    1.193589
# 2002-09-10   -2.674633
# 2002-09-11    2.193126
# 2002-09-12    0.155866
# 2002-09-13   -0.775374
# 2002-09-14    0.860892
# 2002-09-15    0.626011
# 2002-09-16    0.271984
# 2002-09-17   -0.476670
# 2002-09-18    0.770113
# 2002-09-19   -0.310065
# 2002-09-20    0.149217
# 2002-09-21   -0.309014
# 2002-09-22   -0.026196
# 2002-09-23   -1.024672
# 2002-09-24    0.199329
# 2002-09-25    0.211030
# 2002-09-26   -0.252311
# Freq: D, Length: 1000, dtype: float64

# longer_ts['2001']
# Out[47]:
# 2001-01-01    1.317540
# 2001-01-02   -0.912171
# 2001-01-03   -0.256076
# 2001-01-04   -1.403169
# 2001-01-05   -0.903692
# 2001-01-06    0.919079
# 2001-01-07    0.570327
# 2001-01-08    0.035452
# 2001-01-09   -0.630673
# 2001-01-10   -0.062464
# 2001-01-11   -0.017008
# 2001-01-12   -1.765367
# 2001-01-13    1.553357
# 2001-01-14    0.956511
# 2001-01-15    0.441139
# 2001-01-16    0.435056
# 2001-01-17   -0.935724
# 2001-01-18   -0.265756
# 2001-01-19   -0.694745
# 2001-01-20   -0.227444
# 2001-01-21    0.656923
# 2001-01-22   -0.346455
# 2001-01-23   -0.519225
# 2001-01-24    1.598068
# 2001-01-25    0.794843
# 2001-01-26   -0.718586
# 2001-01-27   -0.438579
# 2001-01-28   -0.458953
# 2001-01-29    1.292265
# 2001-01-30   -2.224920
#                 ...
# 2001-12-02    1.953283
# 2001-12-03   -0.969557
# 2001-12-04   -0.569028
# 2001-12-05   -2.172492
# 2001-12-06    0.822711
# 2001-12-07    0.341336
# 2001-12-08   -0.472392
# 2001-12-09    1.064645
# 2001-12-10   -0.056076
# 2001-12-11   -0.641191
# 2001-12-12   -0.651606
# 2001-12-13    0.285499
# 2001-12-14   -1.211913
# 2001-12-15    0.018668
# 2001-12-16    0.660656
# 2001-12-17   -0.278250
# 2001-12-18    0.716852
# 2001-12-19   -0.403970
# 2001-12-20    1.399517
# 2001-12-21   -0.048116
# 2001-12-22   -0.933083
# 2001-12-23    0.836220
# 2001-12-24   -0.744998
# 2001-12-25   -0.126243
# 2001-12-26    1.620523
# 2001-12-27   -0.908558
# 2001-12-28    0.993115
# 2001-12-29    0.965368
# 2001-12-30   -0.701224
# 2001-12-31    1.186043
# Freq: D, Length: 365, dtype: float64

##指定年与指定月
# longer_ts['2001-05']
# Out[48]:
# 2001-05-01   -1.533404
# 2001-05-02    1.356391
# 2001-05-03   -0.288397
# 2001-05-04    0.513019
# 2001-05-05    0.911312
# 2001-05-06    0.350545
# 2001-05-07    1.799375
# 2001-05-08    0.683350
# 2001-05-09   -0.990296
# 2001-05-10   -1.768709
# 2001-05-11    0.507558
# 2001-05-12    0.998255
# 2001-05-13    0.192033
# 2001-05-14    1.349294
# 2001-05-15   -1.455087
# 2001-05-16    0.044138
# 2001-05-17    1.526771
# 2001-05-18   -0.593891
# 2001-05-19    0.610433
# 2001-05-20   -1.111744
# 2001-05-21   -0.495544
# 2001-05-22   -2.246759
# 2001-05-23    0.377939
# 2001-05-24    0.519590
# 2001-05-25    0.302864
# 2001-05-26    1.889964
# 2001-05-27    0.540878
# 2001-05-28    0.683768
# 2001-05-29    1.134037
# 2001-05-30    0.997228
# 2001-05-31   -0.296737
# Freq: D, dtype: float64
#
# # datetime对象也可以进行切片：
# ts[datetime(2011 , 1, 7):]
# Out[49]:
# 2011-01-07   -0.617048
# 2011-01-08   -0.066532
# 2011-01-10    1.075925
# 2011-01-12    0.860212
# dtype: float64
#
# # 由于大部分时间序列数据都是按照时间先后排序的，
# # 因此你也可以用不存在于该时间序列中的时间戳对其进行切片（即范围查询）：
# ts
# Out[50]:
# 2011-01-02    0.914789
# 2011-01-05    0.489796
# 2011-01-07   -0.617048
# 2011-01-08   -0.066532
# 2011-01-10    1.075925
# 2011-01-12    0.860212
# dtype: float64
#
# ts['1/6/2011':'1/11/2011']
# Out[51]:
# 2011-01-07   -0.617048
# 2011-01-08   -0.066532
# 2011-01-10    1.075925
# dtype: float64
#
# # 截取两个日期之间TimeSeries：
# ts.truncate(after = '1/9/2011')
# Out[52]:
# 2011-01-02    0.914789
# 2011-01-05    0.489796
# 2011-01-07   -0.617048
# 2011-01-08   -0.066532
# dtype: float64
#
# # 对DataFrame的行进行索引：
# dates = pd.date_range('1/1/2000' , periods = 100 , freq = 'W-WED')
# long_df = pd.DataFrame(np.random.randn(100,4) ,
#                        index=dates,
#                        columns=['Colorado', 'Texas',
#                                 'New York', 'Ohio'])
# long_df.loc['5-2001']
# Out[56]:
#             Colorado     Texas  New York      Ohio
# 2001-05-02  1.292405 -1.281803 -0.783002  0.838881
# 2001-05-09 -0.522136  0.113902  0.919578  0.537855
# 2001-05-16 -0.412667 -0.281727  0.642053 -0.710212
# 2001-05-23  1.975245  0.357373  0.383442 -1.325706
# 2001-05-30 -0.484378  1.252110  0.238225  0.554503
#
# #### 11.2.2 带有重复索引的时间序列
#
# ## 多个数据在同一个时间点上
# dates = pd.DatetimeIndex(['1/1/2000' , '1/2/2000' , '1/2/2000' ,
#                           '1/2/2000' , '1/3/2000'])
# dus_ts = pd.Series(np.arange(5) , index= dates)
# dus_ts
# Out[57]:
# 2000-01-01    0
# 2000-01-02    1
# 2000-01-02    2
# 2000-01-02    3
# 2000-01-03    4
# dtype: int32
#
# # 通过检查索引的is_unique属性，我们就可以知道它是不是唯一的：
#
# dus_ts.index.is_unique
# Out[59]: False
#
# # 对这个时间序列进行索引，要么产生标量值，要么产生切片，
# # 具体要看所选的时间点是否重复：
# dus_ts['1/3/2000']             # 产生的是标量值
# Out[60]: 4
# dus_ts['1/2/2000']             # 产生的是索引
# Out[61]:
# 2000-01-02    1
# 2000-01-02    2
# 2000-01-02    3
# dtype: int32
#
# # 假设你想要对具有非唯一时间戳的数据进行聚合。
# # 一个办法是使用groupby，并传入level=0：
# grouped = dus_ts.groupby(level=0)
# grouped.mean()
# Out[62]:
# 2000-01-01    0
# 2000-01-02    2
# 2000-01-03    4
# dtype: int32                    # 为什么书上产生的数据类型是int64 , 我这里却是int32?
#
# grouped.count()
# Out[63]:
# 2000-01-01    1
# 2000-01-02    3
# 2000-01-03    1
# dtype: int64



#### 11.3 日期的范围、频率以及移动

# dates = [datetime(2011, 1, 2), datetime(2011, 1, 5),
#          datetime(2011, 1, 7), datetime(2011, 1, 8),
#          datetime(2011, 1, 10), datetime(2011, 1, 12)]
# ts = pd.Series(np.random.randn(6), index=dates)
# ts
# Out[8]:
# 2011-01-02   -0.674527
# 2011-01-05   -2.571699
# 2011-01-07   -0.113400
# 2011-01-08   -0.901587
# 2011-01-10   -1.816960
# 2011-01-12    0.303746
# dtype: float64

## 将之前那个时间序列转换为一个具有固定频率（每日）的时间序列，
# 只需调用resample即可：
# resampler = ts.resample('D')
# resampler
# Out[10]: DatetimeIndexResampler [freq=<Day>, axis=0, closed=left, label=left, convention=start, base=0]


## 11.3.1 生成日期范围

# pandas.date_range可用于根据指定的频率生成指定长度的DatetimeIndex：
# index = pd.date_range('2012-04-01' , '2012-06-01')
# index
# Out[12]:
# DatetimeIndex(['2012-04-01', '2012-04-02', '2012-04-03', '2012-04-04',
#                '2012-04-05', '2012-04-06', '2012-04-07', '2012-04-08',
#                '2012-04-09', '2012-04-10', '2012-04-11', '2012-04-12',
#                '2012-04-13', '2012-04-14', '2012-04-15', '2012-04-16',
#                '2012-04-17', '2012-04-18', '2012-04-19', '2012-04-20',
#                '2012-04-21', '2012-04-22', '2012-04-23', '2012-04-24',
#                '2012-04-25', '2012-04-26', '2012-04-27', '2012-04-28',
#                '2012-04-29', '2012-04-30', '2012-05-01', '2012-05-02',
#                '2012-05-03', '2012-05-04', '2012-05-05', '2012-05-06',
#                '2012-05-07', '2012-05-08', '2012-05-09', '2012-05-10',
#                '2012-05-11', '2012-05-12', '2012-05-13', '2012-05-14',
#                '2012-05-15', '2012-05-16', '2012-05-17', '2012-05-18',
#                '2012-05-19', '2012-05-20', '2012-05-21', '2012-05-22',
#                '2012-05-23', '2012-05-24', '2012-05-25', '2012-05-26',
#                '2012-05-27', '2012-05-28', '2012-05-29', '2012-05-30',
#                '2012-05-31', '2012-06-01'],
#               dtype='datetime64[ns]', freq='D')

# 默认情况下，date_range会产生按天计算的时间点。
# 如果只传入起始或结束日期，那就还得传入一个表示一段时间的数字：
# start和end定义了日期索引的严格边界

# pd.date_range(start='2012-04-01' , periods=20)
# Out[13]:
# DatetimeIndex(['2012-04-01', '2012-04-02', '2012-04-03', '2012-04-04',
#                '2012-04-05', '2012-04-06', '2012-04-07', '2012-04-08',
#                '2012-04-09', '2012-04-10', '2012-04-11', '2012-04-12',
#                '2012-04-13', '2012-04-14', '2012-04-15', '2012-04-16',
#                '2012-04-17', '2012-04-18', '2012-04-19', '2012-04-20'],
#               dtype='datetime64[ns]', freq='D')

# pd.date_range(end='2012-06-01' , periods = 20)
# Out[15]:
# DatetimeIndex(['2012-05-13', '2012-05-14', '2012-05-15', '2012-05-16',
#                '2012-05-17', '2012-05-18', '2012-05-19', '2012-05-20',
#                '2012-05-21', '2012-05-22', '2012-05-23', '2012-05-24',
#                '2012-05-25', '2012-05-26', '2012-05-27', '2012-05-28',
#                '2012-05-29', '2012-05-30', '2012-05-31', '2012-06-01'],
#               dtype='datetime64[ns]', freq='D')

# 生成一个由每月最后一个工作日组成的日期索引，
# 可以传入"BM"频率（表示businessend of month，表11-4是频率列表）电子版P358，
# 这样就只会包含时间间隔内（或刚好在边界上的）符合频率要求的日期：

# pd.date_range('2000-01-01' , '2000-12-01' , freq = 'BM')
# Out[16]:
# DatetimeIndex(['2000-01-31', '2000-02-29', '2000-03-31', '2000-04-28',
#                '2000-05-31', '2000-06-30', '2000-07-31', '2000-08-31',
#                '2000-09-29', '2000-10-31', '2000-11-30'],
#               dtype='datetime64[ns]', freq='BM')

# date_range默认会保留起始和结束时间戳的时间信息（如果有的话）(这里的时间信息就是说的几时几分)：
# pd.date_range('2012-05-02 12:56:31' , periods = 5)
# Out[17]:
# DatetimeIndex(['2012-05-02 12:56:31', '2012-05-03 12:56:31',
#                '2012-05-04 12:56:31', '2012-05-05 12:56:31',
#                '2012-05-06 12:56:31'],
#               dtype='datetime64[ns]', freq='D')

# 有时，虽然起始和结束日期带有时间信息，但你希望产生一组标准化为零点的
# （normalize）时间戳。normalize选项即可实现该功能：
# pd.date_range('2012-05-02 12:56:31' , periods=5 , normalize=True)
# Out[18]:
# DatetimeIndex(['2012-05-02', '2012-05-03', '2012-05-04', '2012-05-05',
#                '2012-05-06'],
#               dtype='datetime64[ns]', freq='D')


##  11.3.2 频率和日期偏置

# from pandas.tseries.offsets import Hour,Minute
#
# hour = Hour()
# hour
# Out[21]: <Hour>

# 对于每个基础频率，都有一个被称为日期偏移量（date offset）的对象与之对应。
# four_hours = Hour(4)
# four_hours
# Out[23]: <4 * Hours>

# 在基础频率前面放上一个整数即可创建倍数：
# pd.date_range('2000-01-01' , '2000-01-03 23:59' , freq='4h')
# Out[24]:
# DatetimeIndex(['2000-01-01 00:00:00', '2000-01-01 04:00:00',
#                '2000-01-01 08:00:00', '2000-01-01 12:00:00',
#                '2000-01-01 16:00:00', '2000-01-01 20:00:00',
#                '2000-01-02 00:00:00', '2000-01-02 04:00:00',
#                '2000-01-02 08:00:00', '2000-01-02 12:00:00',
#                '2000-01-02 16:00:00', '2000-01-02 20:00:00',
#                '2000-01-03 00:00:00', '2000-01-03 04:00:00',
#                '2000-01-03 08:00:00', '2000-01-03 12:00:00',
#                '2000-01-03 16:00:00', '2000-01-03 20:00:00'],
#               dtype='datetime64[ns]', freq='4H')

# 偏移量对象都可通过加法进行连接：
# Hour(2) + Minute(30)
# Out[25]: <150 * Minutes>

# pd.date_range('2000-01-01' , periods=10 , freq = '1h30min')
# Out[26]:
# DatetimeIndex(['2000-01-01 00:00:00', '2000-01-01 01:30:00',
#                '2000-01-01 03:00:00', '2000-01-01 04:30:00',
#                '2000-01-01 06:00:00', '2000-01-01 07:30:00',
#                '2000-01-01 09:00:00', '2000-01-01 10:30:00',
#                '2000-01-01 12:00:00', '2000-01-01 13:30:00'],
#               dtype='datetime64[ns]', freq='90T')

### 11.3.2.1 月中某星期的日期WOM(Week of Month)
# rng = pd.date_range('2012-01-01' , '2012-09-01' , freq='WOM-3FRI')
# list(rng)
# Out[27]:
# [Timestamp('2012-01-20 00:00:00', freq='WOM-3FRI'),
#  Timestamp('2012-02-17 00:00:00', freq='WOM-3FRI'),
#  Timestamp('2012-03-16 00:00:00', freq='WOM-3FRI'),
#  Timestamp('2012-04-20 00:00:00', freq='WOM-3FRI'),
#  Timestamp('2012-05-18 00:00:00', freq='WOM-3FRI'),
#  Timestamp('2012-06-15 00:00:00', freq='WOM-3FRI'),
#  Timestamp('2012-07-20 00:00:00', freq='WOM-3FRI'),
#  Timestamp('2012-08-17 00:00:00', freq='WOM-3FRI')]


## 11.3.3 移动（超前和滞后）数据

# 移动（shifting）指的是沿着时间轴将数据前移或后移。
# Series和DataFrame都有一个shift方法用于执行单纯的前移或后移操作，保持索引不变：

# ts = pd.Series(np.random.randn(4) ,
#                index=pd.date_range('1/1/2000' , periods=4 , freq='M'))
# ts
# Out[32]:
# 2000-01-31   -0.543081
# 2000-02-29   -0.535254
# 2000-03-31    0.643027
# 2000-04-30    0.268634
# Freq: M, dtype: float64

# ts.shift(2)           # 索引不变，单纯把数值前后移动 ,这种移动会在前后产生缺失数据
# Out[33]:
# 2000-01-31         NaN
# 2000-02-29         NaN
# 2000-03-31   -0.543081
# 2000-04-30   -0.535254
# Freq: M, dtype: float64

# ts.shift(-2)
# Out[34]:
# 2000-01-31    0.643027
# 2000-02-29    0.268634
# 2000-03-31         NaN
# 2000-04-30         NaN
# Freq: M, dtype: float64

# shift通常用于计算一个时间序列或多个时间序列（如DataFrame的列）中的
# 百分比变化。可以这样表达：
# ts / ts.shift(1)-1
# Out[35]:
# 2000-01-31         NaN
# 2000-02-29   -0.014413
# 2000-03-31   -2.201350
# 2000-04-30   -0.582236
# Freq: M, dtype: float64

# 对时间戳进行位移而不是对数据进行简单位移：
# ts.shift(2,freq='M')
# Out[37]:
# 2000-03-31   -0.543081
# 2000-04-30   -0.535254
# 2000-05-31    0.643027
# 2000-06-30    0.268634
# Freq: M, dtype: float64

# ts.shift(3,freq='D')
# Out[38]:
# 2000-02-03   -0.543081
# 2000-03-03   -0.535254
# 2000-04-03    0.643027
# 2000-05-03    0.268634
# dtype: float64
# ts.shift(1,freq='90T')
# Out[39]:
# 2000-01-31 01:30:00   -0.543081
# 2000-02-29 01:30:00   -0.535254
# 2000-03-31 01:30:00    0.643027
# 2000-04-30 01:30:00    0.268634
# Freq: M, dtype: float64

### 11.3.3.1 通过偏移量对日期进行位移
# from pandas.tseries.offsets import Day,MonthEnd
# In[41]: now = datetime(2011 , 11,17)
# In[42]: now+ 3*Day()
# Out[42]: Timestamp('2011-11-20 00:00:00')

# 如果加的是锚点偏移量（比如MonthEnd），第一次增量会将原日期向前滚动
# 到符合频率规则的下一个日期：
# In[43]: now +MonthEnd()
# Out[43]: Timestamp('2011-11-30 00:00:00')
# In[44]: now + MonthEnd(2)
# Out[44]: Timestamp('2011-12-31 00:00:00')

# 通过锚点偏移量的rollforward和rollback方法，可明确地将日期向前或向后“滚 动”：
# offset = MonthEnd()
# offset.rollforward(now)
# Out[46]: Timestamp('2011-11-30 00:00:00')
# offset.rollback(now)
# Out[47]: Timestamp('2011-10-31 00:00:00')

# 结合groupby使用这两个“滚动”方法：
# In[49]: ts = pd.Series(np.random.randn(20) ,
#    ...:                index = pd.date_range('1/15/2000' , periods=20 , freq='4d'))
# In[50]: ts
# Out[50]:
# 2000-01-15   -1.819160
# 2000-01-19    0.640909
# 2000-01-23   -1.418759
# 2000-01-27    0.366897
# 2000-01-31   -0.652367
# 2000-02-04    0.248324
# 2000-02-08   -1.558448
# 2000-02-12   -0.487232
# 2000-02-16    1.868596
# 2000-02-20   -1.701656
# 2000-02-24    0.815670
# 2000-02-28   -1.101546
# 2000-03-03    0.652731
# 2000-03-07    0.986626
# 2000-03-11    0.042436
# 2000-03-15    0.196228
# 2000-03-19    0.178814
# 2000-03-23   -1.068953
# 2000-03-27    0.450038
# 2000-03-31    0.968265
# Freq: 4D, dtype: float64
#
# In[51]: ts.groupby(offset.rollforward).mean()
# Out[51]:
# 2000-01-31   -0.576496
# 2000-02-29   -0.273756
# 2000-03-31    0.300773
# dtype: float64

# # 这个方法更简洁
# ts.resample('M').mean()
# Out[52]:
# 2000-01-31   -0.576496
# 2000-02-29   -0.273756
# 2000-03-31    0.300773
# Freq: M, dtype: float64















































